---
# roles/kvm-ubuntu-vm/tasks/main.yml

- name: Ensure required packages are installed
  apt:
    name:
      - qemu-kvm
      - libvirt-daemon-system
      - virtinst
      - bridge-utils
      - python3-libvirt
      - genisoimage
      - cloud-utils
      - cloud-image-utils
    state: present
    update_cache: yes

- name: Ensure libvirt service is running
  service:
    name: libvirtd
    state: started
    enabled: yes

- name: Create directory for HTTP server
  file:
    path: "{{ http_server_dir }}"
    state: directory
    mode: '0755'

- name: Create images directory
  file:
    path: "{{ http_server_dir }}/images"
    state: directory
    mode: '0755'

- name: Create cloud-init directory
  file:
    path: "{{ http_server_dir }}/cloud-init"
    state: directory
    mode: '0755'

- name: Download Ubuntu cloud image if not already present
  get_url:
    url: "{{ cloud_image_url }}"
    dest: "{{ http_server_dir }}/images/{{ cloud_image_name }}"
    mode: '0644'

- name: Create user-data file for cloud-init
  copy:
    dest: "{{ http_server_dir }}/cloud-init/user-data"
    content: |
      #cloud-config
      hostname: {{ vm_hostname }}
      fqdn: {{ vm_hostname }}.local
      manage_etc_hosts: true
      
      # User configuration
      users:
        - name: {{ vm_user }}
          passwd: {{ vm_password | password_hash('sha512') }}
          lock_passwd: false
          shell: /bin/bash
          sudo: ALL=(ALL) NOPASSWD:ALL
          groups: sudo
          home: /home/{{ vm_user }}
      {% if vm_ssh_public_key | length > 0 %}
          ssh_authorized_keys:
            - {{ vm_ssh_public_key }}
      {% endif %}
      
      chpasswd:
        expire: false
      ssh_pwauth: true
      
      # Package management
      package_update: true
      package_upgrade: true
      
      # NTP Configuration
      ntp:
        enabled: true
        servers:
      {% for server in vm_ntp_servers %}
          - {{ server }}
      {% endfor %}
      
      # Additional configuration
      timezone: UTC
      
      # Run commands on first boot
      runcmd:
        - echo "Cloud-init setup completed" | tee /var/log/cloud-init-setup.log
    mode: '0644'

- name: Create meta-data file for cloud-init
  copy:
    dest: "{{ http_server_dir }}/cloud-init/meta-data"
    content: |
      instance-id: {{ vm_name }}
      local-hostname: {{ vm_hostname }}
    mode: '0644'

- name: Create network-config file for cloud-init
  copy:
    dest: "{{ http_server_dir }}/cloud-init/network-config"
    content: |
      version: 2
      ethernets:
        enp1s0:
          dhcp4: no
          addresses: [{{ vm_ip_address }}/{{ vm_cidr_prefix }}]
          gateway4: {{ vm_gateway }}
          nameservers:
            addresses: [{{ vm_dns_servers }}]
            search: [{{ vm_dns_search_domains | replace(' ', ', ') }}]
    mode: '0644'

- name: Start HTTP server in background
  shell: |
    cd {{ http_server_dir }} && nohup python3 -m http.server {{ http_server_port }} > /dev/null 2>&1 &
    echo $! > /tmp/http_server.pid
  args:
    creates: /tmp/http_server.pid

# Handle disk creation based on disk type
- name: Create working directory for VM disk
  file:
    path: "/var/lib/libvirt/images"
    state: directory
    mode: '0755'

- name: Create qcow2 disk
  block:
    - name: Create a working copy of the cloud image (qcow2)
      copy:
        src: "{{ http_server_dir }}/images/{{ cloud_image_name }}"
        dest: "/var/lib/libvirt/images/{{ vm_name }}.qcow2"
        remote_src: yes
        mode: '0644'
    - name: Resize the qcow2 disk image
      command: qemu-img resize /var/lib/libvirt/images/{{ vm_name }}.qcow2 {{ vm_disk_size_gb }}G
  when: vm_disk_type == 'qcow2'

- name: Create raw disk
  block:
    - name: Convert to raw image
      command: >
        qemu-img convert -f qcow2 -O raw 
        {{ http_server_dir }}/images/{{ cloud_image_name }} 
        /var/lib/libvirt/images/{{ vm_name }}.raw
    - name: Resize the raw disk image
      command: qemu-img resize -f raw /var/lib/libvirt/images/{{ vm_name }}.raw {{ vm_disk_size_gb }}G
  when: vm_disk_type == 'raw'

- name: Verify device exists when using device type
  stat:
    path: "{{ vm_device_path }}"
  register: device_check
  when: vm_disk_type == 'device'

- name: Fail if device doesn't exist
  fail:
    msg: "The device {{ vm_device_path }} does not exist"
  when: vm_disk_type == 'device' and not device_check.stat.exists

- name: Create cloud-init ISO
  shell: |
    cloud-localds -v \
      --network-config={{ http_server_dir }}/cloud-init/network-config \
      /var/lib/libvirt/images/{{ vm_name }}-seed.iso \
      {{ http_server_dir }}/cloud-init/user-data \
      {{ http_server_dir }}/cloud-init/meta-data

- name: Set VM disk path based on disk type
  set_fact:
    vm_disk_path: "/var/lib/libvirt/images/{{ vm_name }}.qcow2"
    vm_disk_format: "qcow2"
  when: vm_disk_type == 'qcow2'

- name: Set VM disk path for raw disk
  set_fact:
    vm_disk_path: "/var/lib/libvirt/images/{{ vm_name }}.raw"
    vm_disk_format: "raw"
  when: vm_disk_type == 'raw'

- name: Set VM disk path for device
  set_fact:
    vm_disk_path: "{{ vm_device_path }}"
    vm_disk_format: "raw"
  when: vm_disk_type == 'device'

- name: Define and start the VM
  shell: |
    virt-install \
      --name {{ vm_name }} \
      --memory {{ vm_memory_mb }} \
      --vcpus {{ vm_vcpus }} \
      --disk path={{ vm_disk_path }},format={{ vm_disk_format }} \
      --disk path=/var/lib/libvirt/images/{{ vm_name }}-seed.iso,device=cdrom \
      --os-variant ubuntu22.04 \
      --virt-type kvm \
      --graphics none \
      --network bridge={{ bridge_interface }},model=virtio \
      --import \
      --noautoconsole

- name: Wait for VM to be running
  virt:
    name: "{{ vm_name }}"
    command: status
  register: vm_status
  until: vm_status.status == 'running'
  retries: 30
  delay: 2

- name: Stop HTTP server
  shell: |
    if [ -f /tmp/http_server.pid ]; then
      kill $(cat /tmp/http_server.pid)
      rm /tmp/http_server.pid
    fi
  ignore_errors: yes

- name: Show VM IP address
  debug:
    msg: "VM {{ vm_name }} is running with IP address {{ vm_ip_address }}"

- name: Show VM connection instructions
  debug:
    msg: "You can connect to the VM using: ssh {{ vm_user }}@{{ vm_ip_address }}"